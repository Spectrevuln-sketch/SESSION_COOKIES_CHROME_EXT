{"version":3,"file":"src_utils_cookieUtils_ts-src_utils_storage_ts-src_configs_config_dev_json.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;AC3OA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://share-cookies/./src/utils/cookieUtils.ts","webpack://share-cookies/./src/utils/storage.ts"],"sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n// Polyfill\nimport { browser } from 'webextension-polyfill-ts';\n// Helpers\nimport { sum, groupBy, sortBy } from 'ramda';\nimport { formatDistanceToNow, fromUnixTime, format, addHours, getUnixTime, parse, } from 'date-fns';\nimport * as R from 'ramda';\nimport { parseDomain, ParseResultType } from \"parse-domain\";\n// Ramda Functions\nexport const groupCookiesByDomain = groupBy((cookie) => cookie.domain);\nexport const sortCookiesByDomain = sortBy((mappedCookies) => mappedCookies.domain.length);\nexport const DATE_TIME_FORMAT = \"yyyy-MM-dd'T'HH:mm\";\nexport const getMainDomain = (url) => {\n    try {\n        const parsedUrl = new URL(url);\n        const hostname = parsedUrl.hostname;\n        // Extract the main domain from the hostname\n        const parts = hostname.split('.');\n        if (parts.length > 2) {\n            // Assuming the domain is the last two parts\n            return parts.slice(-2).join('.');\n        }\n        return hostname; // Return as is if it's already a main domain\n    }\n    catch (error) {\n        console.error('Error parsing URL:', error);\n        return ''; // Return empty string if parsing fails\n    }\n};\nexport const formatCookies = (cookies, url) => __awaiter(void 0, void 0, void 0, function* () {\n    // @ts-ignore\n    const newCookie = formatNewCookie(cookies, url);\n    console.log('FINAL COOKIE', newCookie);\n    browser.cookies\n        .remove({\n        url: newCookie.url,\n        name: newCookie.name,\n        storeId: newCookie.storeId,\n    })\n        .then(() => {\n        browser.cookies.set(newCookie).then(e => {\n            console.log('FIN', e);\n        });\n    });\n});\nexport const changeActiveTabURL = (newURL) => __awaiter(void 0, void 0, void 0, function* () {\n    // Mendapatkan tab yang sedang aktif\n    const [activeTab] = yield browser.tabs.query({ active: true, currentWindow: true });\n    if (activeTab) {\n        // Mengubah URL tab aktif\n        yield browser.tabs.update(activeTab.id, { url: newURL });\n        console.log(\"Tab URL updated to:\", newURL);\n    }\n    else {\n        console.log(\"No active tab found.\");\n    }\n});\nexport const perfTracker = (name, fnc) => __awaiter(void 0, void 0, void 0, function* () {\n    console.time(name);\n    yield fnc();\n    console.timeEnd(name);\n});\nexport const getCookiesSize = (cookies, returnNumber = false) => {\n    const sizes = cookies.map(cookie => calculateOneCookieSize(cookie));\n    const size = sum(sizes);\n    if (returnNumber)\n        return size;\n    return humanReadableSize(size);\n};\nexport const humanReadableSize = (size) => size > 1000 ? `${(size / 1000).toFixed(2)} kb` : `${size} bytes`;\n// export const getSizeOfValues = (...args: string[]) =>\n//   Buffer.byteLength(args.join(''));\nexport const getSizeOfValues = (...args) => {\n    const encoder = new TextEncoder();\n    return encoder.encode(args.join('')).length;\n};\nexport const calculateOneCookieSize = (cookie, humanReadable = false) => {\n    const size = getSizeOfValues(cookie.name, cookie.value);\n    if (humanReadable)\n        return humanReadableSize(size);\n    return size;\n};\nexport const getCurrentDomainFromUrl = (url) => {\n    if (!url)\n        return '';\n    const parsedDomainUrl = parseDomain(url);\n    if (parsedDomainUrl.type !== ParseResultType.Listed)\n        return '';\n    return [parsedDomainUrl.domain, parsedDomainUrl.topLevelDomains].join('.');\n};\nexport const getCurrentUrlFromTab = (fullUrl) => {\n    if (R.isEmpty(fullUrl) || R.isNil(fullUrl)) {\n        return null;\n    }\n    const parsedDomainUrl = parseDomain(fullUrl);\n    if (parsedDomainUrl.type !== ParseResultType.Listed) {\n        return null;\n    }\n    const currentUrl = (parsedDomainUrl === null || parsedDomainUrl === void 0 ? void 0 : parsedDomainUrl.subDomains[0]) === '' || (parsedDomainUrl === null || parsedDomainUrl === void 0 ? void 0 : parsedDomainUrl.subDomains[0]) === 'www'\n        ? [parsedDomainUrl.domain, parsedDomainUrl.topLevelDomains].join('.')\n        : [\n            parsedDomainUrl === null || parsedDomainUrl === void 0 ? void 0 : parsedDomainUrl.subDomains[0],\n            parsedDomainUrl === null || parsedDomainUrl === void 0 ? void 0 : parsedDomainUrl.domain,\n            parsedDomainUrl === null || parsedDomainUrl === void 0 ? void 0 : parsedDomainUrl.topLevelDomains,\n        ].join('.');\n    return currentUrl;\n};\nexport const formatNewCookie = (cookie, currentUrl) => {\n    const PICK_FIELDS = [\n        'name',\n        'storeId',\n        'value',\n        'expirationDate',\n        'path',\n        'httpOnly',\n        'secure',\n    ];\n    const secure = currentUrl.indexOf('https://') === 0;\n    const hostOnlyDomain = cookie.domain.substr(0, 1) === '.'\n        ? cookie.domain.substring(1)\n        : cookie.domain;\n    // @ts-ignore\n    return Object.assign(Object.assign(Object.assign({}, R.pick(PICK_FIELDS, Object.assign(Object.assign({}, cookie), { expirationDate: getUnixTime(parse(cookie.expirationDateString, DATE_TIME_FORMAT, new Date())) }))), (!cookie.hostOnly && Boolean(cookie.domain.substr(0, 1) === '.')\n        ? { domain: hostOnlyDomain }\n        : {})), { url: `http${secure ? 's' : ''}://${hostOnlyDomain}${cookie.path}` });\n};\nexport const getURL = (url) => {\n    if (!url)\n        return '';\n    try {\n        const domain = new URL(url).hostname;\n        return domain === 'newtab' ? '' : domain.replace('www.', '');\n    }\n    catch (error) {\n        return '';\n    }\n};\nexport const openTabAndSetCookie = (cookies, url) => __awaiter(void 0, void 0, void 0, function* () {\n    try {\n        // Buat tab baru\n        const tab = yield browser.tabs.create({ url });\n        // Tunggu hingga tab selesai dimuat\n        browser.tabs.onUpdated.addListener((tabId, changeInfo) => __awaiter(void 0, void 0, void 0, function* () {\n            if (tabId === tab.id && changeInfo.status === 'complete') {\n                // Setel cookie untuk tab yang baru dibuat\n                try {\n                    formatCookies(cookies, url);\n                    console.log('Cookie telah diatur dengan sukses.');\n                }\n                catch (error) {\n                    console.error('Error mengatur cookie:', error);\n                }\n            }\n        }));\n    }\n    catch (error) {\n        console.error('Error membuka tab:', error);\n    }\n});\nexport const openNewTab = (url) => __awaiter(void 0, void 0, void 0, function* () {\n    try {\n        const tab = yield browser.tabs.create({ url, active: false });\n        return tab;\n    }\n    catch (error) {\n        console.error('Error opening new tab:', error);\n    }\n});\nexport const currentTab = () => __awaiter(void 0, void 0, void 0, function* () {\n    const tab = yield browser.tabs.query({\n        active: true,\n        currentWindow: true,\n    });\n    return tab[0];\n});\nexport const getAllCookies = () => __awaiter(void 0, void 0, void 0, function* () {\n    const tab = yield currentTab();\n    // Get the main domain from the URL\n    const mainDomain = getMainDomain(tab.url);\n    // If domain extraction failed, return null\n    if (!mainDomain) {\n        return null;\n    }\n    // Fetch cookies based on the main domain\n    const cookies = yield browser.cookies.getAll({ domain: mainDomain });\n    console.log('Parsed Domain cookies >>>', cookies);\n    // Group cookies by domain\n    const groupedCookies = groupCookiesByDomain(cookies);\n    // Map cookies to the desired format\n    const mappedCookies = Object.entries(groupedCookies).map(([domain, cookiesList]) => {\n        const size = getCookiesSize(cookiesList, true);\n        const formattedCookies = cookiesList.map((cookie) => {\n            const cookieSize = calculateOneCookieSize(cookie);\n            const newCookie = Object.assign(Object.assign({}, cookie), { size: cookieSize, formatedSize: humanReadableSize(cookieSize), expirationMessage: getExpirationDate(cookie), expirationDateString: getExpirationDateString(cookie.expirationDate), badges: generateBadges(cookie) });\n            return newCookie;\n        });\n        return {\n            domain,\n            size,\n            formatedSize: humanReadableSize(size),\n            cookies: formattedCookies,\n        };\n    });\n    return sortCookiesByDomain(mappedCookies);\n});\nexport const compareCookies = (newCookies, oldCookies) => JSON.stringify(newCookies) === JSON.stringify(oldCookies);\nexport const getExpirationDate = (cookie) => {\n    if (cookie.session)\n        return 'Session';\n    if (!cookie.expirationDate)\n        return null;\n    return formatDistanceToNow(fromUnixTime(cookie.expirationDate));\n};\nexport const getExpirationDateString = (time = null) => {\n    return format(time ? fromUnixTime(time) : addHours(new Date(), 1), DATE_TIME_FORMAT);\n};\nexport const generateBadges = (cookie) => {\n    let badges = [];\n    if (cookie.httpOnly)\n        badges.push({\n            badgeName: 'HttpOnly',\n        });\n    if (cookie.secure)\n        badges.push({\n            badgeName: 'Secure',\n        });\n    return badges;\n};\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nexport function getCookieFromExtension() {\n    // Pastikan ini sesuai dengan URL dari mana cookie disetel\n    const cookieURL = 'chrome-extension://' + chrome.runtime.id;\n    let tokenCookies;\n    chrome.cookies.get({ url: cookieURL, name: 'yourCookieName' }, (cookie) => {\n        if (cookie) {\n            tokenCookies = cookie.value;\n        }\n        else {\n            tokenCookies = null;\n        }\n    });\n    return tokenCookies;\n}\n;\nexport function setStoredToken(token, ttl) {\n    const now = new Date().getTime(); // Waktu saat ini dalam milidetik\n    const expiry = now + ttl; // Hitung waktu kedaluwarsa\n    const vals = {\n        token,\n        expiry\n    };\n    return new Promise((resolve) => {\n        chrome.storage.local.set(vals, () => {\n            resolve();\n        });\n    });\n}\nexport function getStoredToken() {\n    return __awaiter(this, void 0, void 0, function* () {\n        const keys = ['token', 'expiry'];\n        return new Promise((resolve) => {\n            chrome.storage.local.get(keys, (res) => {\n                var _a;\n                const now = new Date().getTime(); // Waktu saat ini dalam milidetik\n                if (res.expiry && now > res.expiry) {\n                    // Jika token sudah kedaluwarsa, hapus dari storage\n                    chrome.storage.local.remove(['token', 'expiry'], () => {\n                        resolve(''); // Token tidak ada atau kedaluwarsa\n                    });\n                }\n                else {\n                    // Jika token masih valid\n                    resolve((_a = res.token) !== null && _a !== void 0 ? _a : '');\n                }\n            });\n        });\n    });\n}\nexport function setStoredCookies(cookiesData) {\n    const vals = {\n        cookiesData\n    };\n    return new Promise((resolve) => {\n        chrome.storage.local.set(vals, () => {\n            resolve();\n        });\n    });\n}\nexport function getStoredCookies() {\n    return __awaiter(this, void 0, void 0, function* () {\n        const keys = ['cookiesData'];\n        return new Promise((resolve) => {\n            chrome.storage.local.get(keys, (res) => {\n                var _a;\n                resolve((_a = res.cookiesData) !== null && _a !== void 0 ? _a : {});\n            });\n        });\n    });\n}\nexport function setFormData(formData) {\n    const vals = {\n        formData\n    };\n    return new Promise((resolve) => {\n        chrome.storage.local.set(vals, () => {\n            resolve();\n        });\n    });\n}\nexport function getFormData() {\n    return __awaiter(this, void 0, void 0, function* () {\n        const keys = ['formData'];\n        return new Promise((resolve) => {\n            chrome.storage.local.get(keys, (res) => {\n                var _a;\n                resolve((_a = res.formData) !== null && _a !== void 0 ? _a : {});\n            });\n        });\n    });\n}\nexport function getUserStorage() {\n    return __awaiter(this, void 0, void 0, function* () {\n        const keys = ['user'];\n        return new Promise((resolve) => {\n            chrome.storage.local.get(keys, (res) => {\n                var _a;\n                resolve((_a = res.user) !== null && _a !== void 0 ? _a : {});\n            });\n        });\n    });\n}\nexport function setUserStorage(userData) {\n    const vals = {\n        user: userData\n    };\n    return new Promise((resolve) => {\n        chrome.storage.local.set(vals, () => {\n            resolve();\n        });\n    });\n}\n"],"names":[],"sourceRoot":""}